/**
</> Original base BochilGaming 
</> Recode simple by @NeKosmic
**/

import t from"mongoose";let{Schema:a,connect:s,model:_model}=t,defaultOptions={useNewUrlParser:!0,useUnifiedTopology:!0};export class mongoDB{constructor(t,a=defaultOptions){this.url=t,this.options=a,this.data=this._data={},this._schema={},this._model={},this.db=s(this.url,{...this.options}).catch(console.error)}async read(){this.conn=await this.db;let t=this._schema=new a({data:{type:Object,required:!0,default:{}}});try{this._model=_model("data",t)}catch{this._model=_model("data")}return this._data=await this._model.findOne({}),this._data?this.data=this._data.data:(this.data={},await this.write(this.data),this._data=await this._model.findOne({})),this.data}write(t){return new Promise(async(a,s)=>t?this._data?void this._model.findById(this._data._id,(i,e)=>i?s(i):(e.data||(e.data={}),e.data=t,this.data={},e.save(a))):a(new this._model({data:t}).save()):s(t))}}export const mongoDBV2=class t{constructor(t,a=defaultOptions){this.url=t,this.options=a,this.models=[],this.data={},this.lists,this.list,this.db=s(this.url,{...this.options}).catch(console.error)}async read(){this.conn=await this.db;let t=new a({data:[{name:String}]});try{this.list=_model("lists",t)}catch(s){this.list=_model("lists")}this.lists=await this.list.findOne({}),this.lists?.data||(await this.list.create({data:[]}),this.lists=await this.list.findOne({}));let i=[];await Promise.all(this.lists.data.map(async({name:t})=>{let s;try{s=_model(t,new a({data:Array}))}catch(e){console.error(e);try{s=_model(t)}catch(d){i.push(t),console.error(d)}}if(s){let h=this.models.findIndex(a=>a.name===t);-1!==h?this.models[h].model=s:this.models.push({name:t,model:s});let l=await s.find({});this.data[t]=Object.fromEntries(l.map(t=>t.data))}}));try{let e=await this.list.findById(this.lists._id);e.data=e.data.filter(t=>!i.includes(t.name)),await e.save()}catch(d){console.error(d)}return this.data}write(t){return new Promise(async(s,i)=>{if(!this.lists||!t)return i(t||this.lists);let e=Object.keys(t),d=[];await Promise.all(e.map(async s=>{let i=this.models.findIndex(t=>t.name===s);if(-1!==i){let e=this.models[i].model;Object.keys(t[s]).length>0&&(await e.deleteMany().catch(console.error),await e.insertMany(Object.entries(t[s]).map(t=>({data:t})))),d.push({name:s})}else{let h=new a({data:Array}),l;try{l=_model(s,h)}catch(n){console.error(n),l=_model(s)}if(l){let o=this.models.findIndex(t=>t.name===s);-1!==o?this.models[o].model=l:this.models.push({name:s,model:l}),await l.insertMany(Object.entries(t[s]).map(t=>({data:t}))),d.push({name:s})}}})),this.list.findById(this.lists._id,async(a,e)=>{if(a)return i(a);e?(e.data=d,await e.save()):(await this.read(),await this.write(t)),this.data={},s()})})}};

/**
[_>] https://github.com/NeKosmic/
[_>] https://gitlab.com/NeKosmic/
**/